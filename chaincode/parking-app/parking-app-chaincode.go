// SPDX-License-Identifier: Apache-2.0

/*
  Sample Chaincode based on Demonstrated Scenario

 This code is based on code written by the Hyperledger Fabric community.
  Original code can be found here: https://github.com/hyperledger/fabric-samples/blob/release/chaincode/fabcar/fabcar.go
*/

package main

/* Imports
* 4 utility libraries for handling bytes, reading and writing JSON,
formatting, and string manipulation
* 2 specific Hyperledger Fabric specific libraries for Smart Contracts
*/
import (
	"bytes"
	"encoding/json"
	"fmt"
	"math"
	"strconv"
	"time"

	"github.com/digitorus/timestamp"

	. "github.com/parking/model"

	"github.com/hyperledger/fabric/common/util"
	"github.com/hyperledger/fabric/core/chaincode/shim"
	sc "github.com/hyperledger/fabric/protos/peer"

	"github.com/parking/parkingservice"
)

// Define the Smart Contract structure
type SmartContract struct {
	ParkingspotService   parkingservice.ParkingspotService
	ParkingTimeService   parkingservice.ParkingTimeService
	UserService          parkingservice.UserService
	ParkingCommonService parkingservice.ParkingCommonService //TESTING
}

/*
 * The Init method *
 called when the Smart Contract "tuna-chaincode" is instantiated by the network
 * Best practice is to have any Ledger initialization in separate function
 -- see initLedger()
*/
func (s *SmartContract) Init(APIstub shim.ChaincodeStubInterface) sc.Response {
	return shim.Success(nil)
}

/*
 * The Invoke method *
 called when an application requests to run the Smart Contract "tuna-chaincode"
 The app also specifies the specific smart contract function to call with args
*/
func (s *SmartContract) Invoke(APIstub shim.ChaincodeStubInterface) sc.Response {

	// Retrieve the requested Smart Contract function and arguments
	function, args := APIstub.GetFunctionAndParameters()
	// Route to the appropriate handler function to interact with the ledger
	if function == "getParkingTime" {
		return s.getParkingTimeC(APIstub, args)
	} else if function == "getParkingTimeC" {
		return s.getParkingTimeC(APIstub, args)
	} else if function == "getParkingTimeK" {
		return s.getParkingTime(APIstub, args)
	} else if function == "findParkingTime" {
		return s.findParkingTime(APIstub, args)
	} else if function == "findBetweenTime" {
		return s.findBetweenTime(APIstub, args)
	} else if function == "save" { //GENERIC save for debugging
		return s.saveCD(APIstub, args)
	} else if function == "saveC" { //GENERIC save for debugging
		return s.saveC(APIstub, args)
	} else if function == "saveCD" { //GENERIC save for debugging
		return s.saveCD(APIstub, args)
	} else if function == "saveReservation" {
		return s.saveReservation(APIstub, args)
	} else if function == "saveParkingtime" {
		return s.saveParkingtime(APIstub, args)
	} else if function == "getAll" {
		return s.getAll(APIstub)
	} else if function == "extendParkingTime" {
		return s.extendParkingTime(APIstub, args)
	} else if function == "iextendParkingTime" {
		return s.iextendParkingTime(APIstub, args)
	} else if function == "EndParking" {
		return s.EndParking(APIstub, args)
	} else if function == "initLedger" {
		return s.initLedger(APIstub)
	}

	return shim.Error(fmt.Sprintf("Invalid Smart Contract function name: %s", function))
}

/*
 * The getParkingTime method *
Used to view the records of one particular tuna
It takes one argument -- the key for the tuna in question
*/
func (s *SmartContract) getParkingTime(APIstub shim.ChaincodeStubInterface, args []string) sc.Response {

	if len(args) != 1 {
		return shim.Error("Incorrect number of arguments. Expecting 1")
	}

	fmt.Printf("- SVENZIK getParkingTime:%s\n", args[0])
	resultAsBytes, _ := APIstub.GetState(args[0])
	if resultAsBytes == nil {
		return shim.Error("Could not locate tuna")
	}
	return shim.Success(resultAsBytes)
}

func (s *SmartContract) getParkingTimeC(APIstub shim.ChaincodeStubInterface, args []string) sc.Response {

	if len(args) != 1 {
		return shim.Error("Incorrect number of arguments. Expecting 1")
	}

	parkingTimeId := args[0]
	fmt.Printf("- SVENZIK getParkingTime:%s\n", parkingTimeId)

	objectKeys := []string{parkingTimeId}
	compositeKey, _ := s.ParkingCommonService.CreateKey(APIstub, ParkingTime{}, objectKeys)
	fmt.Printf("Getting using key: %s\n", compositeKey)

	// parkingTime, _ := s.ParkingTimeService.Get(APIstub, parkingTimeId)
	// parkingTime, _ := s.ParkingTimeService.GetWithKeys(APIstub, objectKeys)
	// parkingTime, _ := s.ParkingCommonService.GetObject(APIstub, objectKeys, ParkingTime{})

	// resultAsBytes, _ := json.Marshal(parkingTime)
	// if resultAsBytes == nil {
	// 	return shim.Error("Could not marshal PT")
	// }
	//FIXME: all should work correctly
	resultAsBytes := []byte("")
	resultAsBytesService := []byte("")

	// resultAsBytesService, err = APIstub.GetState(compositeKey)
	// // resultAsBytes = append(resultAsBytes, []byte("\nNOSERVICE: ")...)
	// resultAsBytes = append(resultAsBytes, resultAsBytesService...)

	parkingTime, _ := s.ParkingCommonService.GetObject(APIstub, objectKeys, ParkingTime{})
	resultAsBytesService, _ = json.Marshal(parkingTime)
	// resultAsBytes = append(resultAsBytes, []byte("\nCSERVICE: ")...)
	resultAsBytes = append(resultAsBytes, resultAsBytesService...)

	// parkingTime, _ = s.ParkingTimeService.GetWithKeys(APIstub, objectKeys)
	// resultAsBytesService, _ = json.Marshal(parkingTime)
	// resultAsBytes = append(resultAsBytes, []byte("\nKSERVICE: ")...)
	// resultAsBytes = append(resultAsBytes, resultAsBytesService...)
	//
	// parkingTime, _ =s.ParkingTimeService.Get(APIstub, parkingTimeId)
	// resultAsBytesService, _ = json.Marshal(parkingTime)
	// resultAsBytes = append(resultAsBytes, []byte("\nOSERVICE: ")...)
	// resultAsBytes = append(resultAsBytes, resultAsBytesService...)

	return shim.Success(resultAsBytes)
}

/*
 * The findParkingTime method *
Used to search the records of one particular tuna
It takes one argument -- the coudhDB query string for the tuna in question
*/
func (s *SmartContract) findParkingTime(APIstub shim.ChaincodeStubInterface, args []string) sc.Response {

	if len(args) != 1 {
		return shim.Error("Incorrect number of arguments. Expecting 1")
	}

	queryString := args[0]
	fmt.Printf("- queryString:\n%s\n", queryString)

	resultsIterator, err := APIstub.GetQueryResult(queryString)
	if err != nil {
		return shim.Error(err.Error())
	}
	defer resultsIterator.Close()

	result, err := s.marshalQueryResult(resultsIterator)
	fmt.Printf("- findParkingTime:\n%s\n", result)

	return shim.Success([]byte(result))
}

func (s *SmartContract) findBetweenTime(APIstub shim.ChaincodeStubInterface, args []string) sc.Response {
	if len(args) != 2 {
		return shim.Error("Incorrect number of arguments. Expecting 2")
	}

	resultsIterator, err := s.findParkingspotOverlaping(APIstub, args[0], args[1])
	if err != nil {
		return shim.Error(err.Error())
	}
	defer resultsIterator.Close()

	result, err := s.marshalQueryResult(resultsIterator)
	fmt.Printf("- findBetweenTime:\n%s\n", result)

	return shim.Success([]byte(result))
}

/*
 * The initLedger method
 */
func (s *SmartContract) initLedger(APIstub shim.ChaincodeStubInterface) sc.Response {
	parkingSpot := []ParkingTime{
		ParkingTime{ParkingStart: time.Now(), ParkingEnd: time.Now(), CostPerMinute: 10, Parkingspot: Parkingspot{Name: "Tartu-Sobra-tee-1-315"}},
		ParkingTime{ParkingStart: time.Now().Add(2 * time.Minute), ParkingEnd: time.Now().Add(5 * time.Minute), CostPerMinute: 10, Parkingspot: Parkingspot{Name: "Tartu-Sobra-tee-1-315"}},
		ParkingTime{ParkingStart: time.Now().Add(10 * time.Minute), ParkingEnd: time.Now().Add(30 * time.Minute), CostPerMinute: 10, Parkingspot: Parkingspot{Name: "Tartu-Sobra-tee-1-315"}},
		ParkingTime{ParkingStart: time.Now().Add(31 * time.Minute), ParkingEnd: time.Now().Add(45 * time.Minute), CostPerMinute: 10, Parkingspot: Parkingspot{Name: "Tartu-Sobra-tee-1-315"}},
		ParkingTime{ParkingStart: time.Now().Add(46 * time.Minute), ParkingEnd: time.Now().Add(105 * time.Minute), CostPerMinute: 10, Parkingspot: Parkingspot{Name: "Tartu-Sobra-tee-1-315"}},
	}

	i := 0
	for i < len(parkingSpot) {
		parkingSpotAsBytes, _ := json.Marshal(parkingSpot[i])
		s.saveParkingtime(APIstub, []string{strconv.Itoa(i + 1), fmt.Sprintf("%s", parkingSpotAsBytes)})
		//APIstub.PutState(strconv.Itoa(i+1), parkingSpotAsBytes)
		fmt.Println("Added", parkingSpot[i])
		i = i + 1
	}

	return shim.Success(nil)
}

/*
 * The save method *
Fisherman like Sarah would use to record each of her parkingSpot catches.
This method takes in five arguments (attributes to be saved in the ledger).
*/
func (s *SmartContract) save(APIstub shim.ChaincodeStubInterface, args []string) sc.Response {

	if len(args) != 2 {
		return shim.Error("Incorrect number of arguments. Expecting 2")
	}

	// parkingTime := ParkingTime{}
	// json.Unmarshal([]byte(args[1]), &parkingTime)
	parkingTime, err := s.unmarshal(args[1])
	if err != nil {
		return shim.Error(fmt.Sprintf("Failed to unmarshal parkingTime: %s", err))
	}

	result, err := s.put(APIstub, args[0], parkingTime)
	if err != nil {
		return shim.Error(fmt.Sprintf("Failed to persist reservation: %s", err))
	}
	return shim.Success(result)
	// resultAsBytes, _ := json.Marshal(parkingTime)
	// err = APIstub.PutState(args[0], resultAsBytes)
	// if err != nil {
	// 	return shim.Error(fmt.Sprintf("Failed to record parkingTime: %s", args[0]))
	// }
	//
	// return shim.Success(resultAsBytes)
}

func (s *SmartContract) saveC(APIstub shim.ChaincodeStubInterface, args []string) sc.Response {

	if len(args) != 2 {
		return shim.Error("Incorrect number of arguments. Expecting 2")
	}

	parkingTime, err := s.unmarshal(args[1])
	if err != nil {
		return shim.Error(fmt.Sprintf("Failed to unmarshal parkingTime: %s", err))
	}

	parkingTime.Id = args[0]
	ptResult, err := s.ParkingTimeService.Save(APIstub, parkingTime)
	if err != nil {
		return shim.Error(fmt.Sprintf("Failed to persist parkingTime: %s", err))
	}

	objectKeys := []string{parkingTime.Id}
	keyString, _ := s.ParkingCommonService.CreateKey(APIstub, parkingTime, objectKeys)
	ptResult.Id = keyString + " from: " + parkingTime.Id

	result, _ := json.Marshal(ptResult)
	return shim.Success(result)
}

func (s *SmartContract) saveCD(APIstub shim.ChaincodeStubInterface, args []string) sc.Response {

	if len(args) != 2 {
		return shim.Error("Incorrect number of arguments. Expecting 2")
	}

	parkingTime, err := s.unmarshal(args[1])
	if err != nil {
		return shim.Error(fmt.Sprintf("Failed to unmarshal parkingTime: %s", err))
	}

	parkingTime.Id = args[0]

	objectKeys := []string{parkingTime.Id}
	compositeKey, _ := s.ParkingCommonService.CreateKey(APIstub, parkingTime, objectKeys)
	fmt.Printf("Saving using key: %s", compositeKey)

	resultAsBytes, err := json.Marshal(parkingTime)
	err = APIstub.PutState(compositeKey, resultAsBytes)

	if err != nil {
		return shim.Error(fmt.Sprintf("Failed to persist parkingTime: %s", err))
	}

	resultAsBytes, err = APIstub.GetState(compositeKey)
	if err != nil {
		return shim.Error(fmt.Sprintf("Failed to get parkingTime: %s", err))
	}

	return shim.Success(resultAsBytes)
}

func (s *SmartContract) saveReservation(APIstub shim.ChaincodeStubInterface, args []string) sc.Response {
	parkingTime, err := s.unmarshal(args[1])
	if err != nil {
		return shim.Error(fmt.Sprintf("Failed to unmarshal parkingTime: %s", args[1]))
	}

	resultsIterator, _ := s.findParkingspotOverlaping(APIstub, parkingTime.ParkingStart.String(), parkingTime.ParkingEnd.String())
	if resultsIterator.HasNext() {
		queryResponse, _ := resultsIterator.Next()
		return shim.Error(fmt.Sprintf("Time is overlaping with : %s", queryResponse))
	}

	parkingTime.ParkingType = "RESERVATION"
	result, err := s.put(APIstub, args[0], parkingTime)
	if err != nil {
		return shim.Error(fmt.Sprintf("Failed to persist reservation: %s", err))
	}
	return shim.Success(result)
}

func (s *SmartContract) saveParkingtime(APIstub shim.ChaincodeStubInterface, args []string) sc.Response {
	parkingTime, err := s.unmarshal(args[1])
	if err != nil {
		return shim.Error(fmt.Sprintf("Failed to unmarshal parkingTime: %s", args[1]))
	}

	resultsIterator, _ := s.findParkingspotOverlaping(APIstub, parkingTime.ParkingStart.String(), parkingTime.ParkingEnd.String())
	if resultsIterator.HasNext() {
		queryResponse, _ := resultsIterator.Next()
		return shim.Error(fmt.Sprintf("Time is overlaping with : %s", queryResponse))
	}

	parkingTime.ParkingType = "PARKING"
	result, err := s.put(APIstub, args[0], parkingTime)
	if err != nil {
		return shim.Error(fmt.Sprintf("Failed to persist parkingTime: %s", err))
	}
	s.ParkingTimeService.Save(APIstub, parkingTime)

	return shim.Success(result)
}

/*
 * The getAll method *
allows for assessing all the records added to the ledger(all tuna catches)
This method does not take any arguments. Returns JSON string containing results.
*/
func (s *SmartContract) getAll(APIstub shim.ChaincodeStubInterface) sc.Response {

	startKey := "0"
	endKey := "999"
	resultsIterator, err := APIstub.GetStateByRange(startKey, endKey)

	// startKey,_ :=  APIstub.CreateCompositeKey("ParkingTime", []string{"1"})
	// endKey,_ := APIstub.CreateCompositeKey("ParkingTime",  []string{"999"})
	// resultsIterator, err := APIstub.GetStateByPartialCompositeKey("ParkingTime", []string{"1"})

	if err != nil {
		return shim.Error(err.Error())
	}
	defer resultsIterator.Close()

	// buffer is a JSON array containing QueryResults
	var buffer bytes.Buffer
	buffer.WriteString("[")

	bArrayMemberAlreadyWritten := false
	for resultsIterator.HasNext() {
		queryResponse, err := resultsIterator.Next()
		if err != nil {
			return shim.Error(err.Error())
		}
		// Add comma before array members,suppress it for the first array member
		if bArrayMemberAlreadyWritten == true {
			buffer.WriteString(",")
		}
		buffer.WriteString("{\"Key\":")
		buffer.WriteString("\"")
		buffer.WriteString(queryResponse.Key)
		buffer.WriteString("\"")

		buffer.WriteString(", \"Record\":")
		// Record is a JSON object, so we write as-is
		buffer.WriteString(string(queryResponse.Value))
		buffer.WriteString("}")
		bArrayMemberAlreadyWritten = true
	}
	buffer.WriteString("]")

	fmt.Printf("- getAll:\n%s\n", buffer.String())

	return shim.Success(buffer.Bytes())
}

/*
 * The extendParkingTime method *
The data in the world state can be updated with who has possession.
This function takes in 2 arguments, tuna id and new holder name.
*/
func (s *SmartContract) extendParkingTime(APIstub shim.ChaincodeStubInterface, args []string) sc.Response {

	if len(args) != 2 {
		return shim.Error("Incorrect number of arguments. Expecting 2")
	}

	//TODO: check if it conflicts with some other parkingTime
	resultAsBytes, _ := APIstub.GetState(args[0])
	if resultAsBytes == nil {
		return shim.Error("Could not locate ParkingTime")
	}
	parkingTime := ParkingTime{}
	json.Unmarshal(resultAsBytes, &parkingTime)
	// Normally check that the specified argument is a valid holder of parkingTime
	// we are skipping this check for this example
	endTime, err := time.Parse(time.RFC3339, args[1])
	if err != nil {
		return shim.Error(fmt.Sprintf("Failed to parse new end parkingTime: %s", args[1]))
	}
	parkingTime.ParkingEnd = endTime

	resultAsBytes, _ = json.Marshal(parkingTime)
	err = APIstub.PutState(args[0], resultAsBytes)
	if err != nil {
		return shim.Error(fmt.Sprintf("Failed to change parkingTime: %s", args[0]))
	}

	return shim.Success(resultAsBytes)
}

/*
 * The extendParkingTime method *
The data in the world state can be updated with who has possession.
This function takes in 2 arguments, tuna id and new holder name.
*/
func (s *SmartContract) iextendParkingTime(APIstub shim.ChaincodeStubInterface, args []string) sc.Response {

	if len(args) != 2 {
		return shim.Error("Incorrect number of arguments. Expecting 2")
	}

	//TODO: check if it conflicts with some other parkingTime
	resultAsBytes, _ := APIstub.GetState(args[0])
	if resultAsBytes == nil {
		return shim.Error("Could not locate ParkingTime")
	}
	parkingTime := ParkingTime{}
	json.Unmarshal(resultAsBytes, &parkingTime)
	// Normally check that the specified argument is a valid holder of parkingTime
	// we are skipping this check for this example
	parkingTime.ParkingStart = parkingTime.ParkingEnd
	endTime, err := time.Parse(time.RFC3339, args[1])
	if err != nil {
		return shim.Error(fmt.Sprintf("Failed to parse new end parkingTime: %s", args[1]))
	}
	parkingTime.ParkingEnd = endTime
	//TODO: fix new id generation
	newId, errAtoi := strconv.Atoi(args[0])
	newId = newId + 1
	if errAtoi != nil {
		newId = -1
	}
	resultAsBytes, _ = json.Marshal(parkingTime)
	err = APIstub.PutState(strconv.Itoa(newId), resultAsBytes)
	if err != nil {
		return shim.Error(fmt.Sprintf("Failed to change parkingTime: %s", args[0]))
	}

	return shim.Success(resultAsBytes)
}

/*
 * The EndParking method *
The data in the world state can be updated with who has possession.
This function takes in 2 arguments, tuna id and new holder name.
*/
func (s *SmartContract) EndParking(APIstub shim.ChaincodeStubInterface, args []string) sc.Response {
	if len(args) != 1 {
		return shim.Error("Incorrect number of arguments. Expecting 1, id of parkingTime")
	}

	parkingTimeId := args[0]
	fmt.Printf("Ending parking for id: %s\n", parkingTimeId)
	//1
	// parkingTime, err := s.ParkingTimeService.Get(APIstub, parkingTimeId)

	//2
	// objectKeys :=  []string{parkingTimeId}
	// parkingTimeObject, err := s.ParkingCommonService.GetObject(APIstub, objectKeys, ParkingTime{})
	// fmt.Printf("Got parking: %s\n", parkingTimeObject)
	// parkingTime, _ := parkingTimeObject.(ParkingTime)

	//3
	objectKeys := []string{parkingTimeId}
	compositeKey, _ := s.ParkingCommonService.CreateKey(APIstub, ParkingTime{}, objectKeys)
	oResultAsBytes, err := APIstub.GetState(compositeKey)
	parkingTime := ParkingTime{}
	err = json.Unmarshal(oResultAsBytes, &parkingTime)

	fmt.Printf("Got parking type: %s\n", parkingTime)
	if err != nil {
		return shim.Error(fmt.Sprintf("Failed to find parkingTime(%s): %s", parkingTimeId, err))
	}

	//TIME CALCULATIONS
	calculatedEndTime := CurrentTimestamp{TimeWindow: time.Minute * 5, Errors: []string{}}
	ts, _ := APIstub.GetTxTimestamp()

	//using current timestamp of server - will not work in multipeer envir
	// calculatedEndTime = time.Now()

	//Using transaction timestamp set by client, unsafe
	calculatedEndTime.TransactionTime = time.Unix(ts.Seconds, int64(ts.Nanos)).UTC()

	//Using transaction timestamp set by client with chekcing window (lets say 5min)
	endorsedEndTime := time.Unix(ts.Seconds, int64(ts.Nanos)).UTC()
	if math.Abs(time.Now().Sub(endorsedEndTime).Minutes()) < calculatedEndTime.TimeWindow.Minutes() {
		calculatedEndTime.TimeWindowCurrentTime = time.Unix(ts.Seconds, int64(ts.Nanos)).UTC()
	}

	// USING Timestamp Protocol
	// Time-Stamp request with nonce, to create with OpenSSL:
	//   $ openssl ts -query -data data.txt -cert -sha256 -out reqnonoce.tsq
	tspResponse := []byte{0x30, 0x82, 0x0d, 0xaf, 0x30, 0x03, 0x02, 0x01, 0x00, 0x30, 0x82, 0x0d, 0xa6, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x07, 0x02, 0xa0, 0x82, 0x0d, 0x97, 0x30, 0x82, 0x0d, 0x93, 0x02, 0x01, 0x03, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x05, 0x2b, 0x0e, 0x03, 0x02, 0x1a, 0x05, 0x00, 0x30, 0x81, 0x8e, 0x06, 0x0b, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x09, 0x10, 0x01, 0x04, 0xa0, 0x7f, 0x04, 0x7d, 0x30, 0x7b, 0x02, 0x01, 0x01, 0x06, 0x0e, 0x2b, 0x06, 0x01, 0x04, 0x01, 0x95, 0x12, 0x02, 0x02, 0x05, 0x02, 0x01, 0x01, 0x01, 0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, 0x01, 0x05, 0x00, 0x04, 0x20, 0xd5, 0x80, 0xb9, 0x49, 0x4d, 0x44, 0x05, 0x2f, 0x61, 0xcd, 0x2d, 0x3d, 0xa5, 0x1f, 0x15, 0x17, 0x52, 0x69, 0x64, 0xbf, 0xf3, 0xcf, 0xe5, 0xc0, 0xa0, 0x1d, 0x9f, 0xdb, 0x8e, 0x45, 0x38, 0x1c, 0x02, 0x08, 0x15, 0x07, 0xcd, 0xe6, 0x01, 0x5a, 0xe1, 0x63, 0x18, 0x13, 0x32, 0x30, 0x31, 0x38, 0x30, 0x31, 0x30, 0x38, 0x31, 0x30, 0x30, 0x39, 0x34, 0x37, 0x2e, 0x33, 0x38, 0x32, 0x5a, 0x30, 0x09, 0x02, 0x01, 0x0a, 0x80, 0x01, 0x01, 0x81, 0x01, 0x01, 0x02, 0x09, 0x00, 0xf8, 0xfe, 0x9f, 0x92, 0x97, 0x94, 0x60, 0x01, 0xa0, 0x82, 0x09, 0xb1, 0x30, 0x82, 0x04, 0xd5, 0x30, 0x82, 0x03, 0xbd, 0xa0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x01, 0x06, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x0b, 0x05, 0x00, 0x30, 0x81, 0xc2, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x41, 0x54, 0x31, 0x0f, 0x30, 0x0d, 0x06, 0x03, 0x55, 0x04, 0x08, 0x13, 0x06, 0x53, 0x74, 0x79, 0x72, 0x69, 0x61, 0x31, 0x0d, 0x30, 0x0b, 0x06, 0x03, 0x55, 0x04, 0x07, 0x13, 0x04, 0x47, 0x72, 0x61, 0x7a, 0x31, 0x26, 0x30, 0x24, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x13, 0x1d, 0x47, 0x52, 0x41, 0x5a, 0x20, 0x55, 0x4e, 0x49, 0x56, 0x45, 0x52, 0x53, 0x49, 0x54, 0x59, 0x20, 0x4f, 0x46, 0x20, 0x54, 0x45, 0x43, 0x48, 0x4e, 0x4f, 0x4c, 0x4f, 0x47, 0x59, 0x31, 0x48, 0x30, 0x46, 0x06, 0x03, 0x55, 0x04, 0x0b, 0x13, 0x3f, 0x49, 0x6e, 0x73, 0x74, 0x69, 0x74, 0x75, 0x74, 0x65, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x41, 0x70, 0x70, 0x6c, 0x69, 0x65, 0x64, 0x20, 0x49, 0x6e, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x50, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73, 0x69, 0x6e, 0x67, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x43, 0x6f, 0x6d, 0x6d, 0x75, 0x6e, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x31, 0x21, 0x30, 0x1f, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x18, 0x49, 0x41, 0x49, 0x4b, 0x2d, 0x54, 0x53, 0x50, 0x20, 0x44, 0x45, 0x4d, 0x4f, 0x20, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x20, 0x43, 0x41, 0x30, 0x1e, 0x17, 0x0d, 0x31, 0x33, 0x30, 0x33, 0x31, 0x34, 0x31, 0x34, 0x30, 0x30, 0x31, 0x39, 0x5a, 0x17, 0x0d, 0x32, 0x33, 0x30, 0x33, 0x31, 0x34, 0x31, 0x34, 0x30, 0x30, 0x31, 0x39, 0x5a, 0x30, 0x81, 0xbf, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x41, 0x54, 0x31, 0x0f, 0x30, 0x0d, 0x06, 0x03, 0x55, 0x04, 0x08, 0x13, 0x06, 0x53, 0x74, 0x79, 0x72, 0x69, 0x61, 0x31, 0x0d, 0x30, 0x0b, 0x06, 0x03, 0x55, 0x04, 0x07, 0x13, 0x04, 0x47, 0x72, 0x61, 0x7a, 0x31, 0x26, 0x30, 0x24, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x13, 0x1d, 0x47, 0x52, 0x41, 0x5a, 0x20, 0x55, 0x4e, 0x49, 0x56, 0x45, 0x52, 0x53, 0x49, 0x54, 0x59, 0x20, 0x4f, 0x46, 0x20, 0x54, 0x45, 0x43, 0x48, 0x4e, 0x4f, 0x4c, 0x4f, 0x47, 0x59, 0x31, 0x48, 0x30, 0x46, 0x06, 0x03, 0x55, 0x04, 0x0b, 0x13, 0x3f, 0x49, 0x6e, 0x73, 0x74, 0x69, 0x74, 0x75, 0x74, 0x65, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x41, 0x70, 0x70, 0x6c, 0x69, 0x65, 0x64, 0x20, 0x49, 0x6e, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x50, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73, 0x69, 0x6e, 0x67, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x43, 0x6f, 0x6d, 0x6d, 0x75, 0x6e, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x31, 0x1e, 0x30, 0x1c, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x15, 0x49, 0x41, 0x49, 0x4b, 0x2d, 0x54, 0x53, 0x50, 0x20, 0x44, 0x45, 0x4d, 0x4f, 0x20, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x30, 0x82, 0x01, 0x22, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x0f, 0x00, 0x30, 0x82, 0x01, 0x0a, 0x02, 0x82, 0x01, 0x01, 0x00, 0xcd, 0x53, 0x85, 0x3e, 0xec, 0x21, 0x54, 0x9a, 0xd3, 0xca, 0x6b, 0x54, 0x2d, 0xcf, 0xe3, 0x60, 0x2f, 0x74, 0xc5, 0x07, 0xf1, 0xad, 0x06, 0x38, 0x90, 0xf2, 0xbf, 0x3a, 0x1d, 0x75, 0xa6, 0x41, 0xc3, 0xdc, 0x74, 0xb1, 0xd8, 0x70, 0x85, 0x8f, 0x8d, 0x72, 0xed, 0x30, 0xab, 0x15, 0x63, 0x03, 0x6a, 0x66, 0xd5, 0xb5, 0x38, 0x95, 0xd8, 0x1f, 0x8d, 0x63, 0x48, 0x67, 0x47, 0x4d, 0xdf, 0xd7, 0xb0, 0xd8, 0x96, 0xcc, 0x61, 0xc4, 0xe8, 0x31, 0x27, 0xd2, 0x03, 0x37, 0x66, 0x01, 0x9d, 0x8d, 0xb4, 0xd8, 0x7b, 0xbf, 0xa6, 0x9d, 0x37, 0xfd, 0x15, 0xaa, 0x91, 0xbe, 0x01, 0xe6, 0x66, 0x3a, 0x07, 0x2b, 0x17, 0x0f, 0xf4, 0x98, 0xf8, 0xfa, 0x53, 0xbd, 0x7e, 0xab, 0xe4, 0x77, 0x04, 0xd5, 0xad, 0xb7, 0x82, 0x1e, 0xa6, 0xc2, 0xa4, 0xdb, 0x9c, 0x47, 0x8d, 0x78, 0xb9, 0x45, 0xbf, 0xfc, 0x16, 0x94, 0xc2, 0xfa, 0x0b, 0x8e, 0x0e, 0x9b, 0x84, 0x7b, 0x5e, 0x28, 0x2d, 0xbc, 0xf7, 0xeb, 0x5e, 0xc2, 0x1c, 0x98, 0x3f, 0xd4, 0x4c, 0xbd, 0xc4, 0x6e, 0xc3, 0x60, 0x18, 0x60, 0xa9, 0x15, 0x1f, 0x69, 0x81, 0xab, 0x61, 0x06, 0x22, 0xb4, 0x0e, 0x5d, 0x8d, 0x6a, 0xf2, 0xb6, 0x28, 0xd7, 0xd0, 0xef, 0x04, 0xfa, 0xc3, 0x5b, 0xa6, 0x71, 0x7e, 0x53, 0x1b, 0xa1, 0x4c, 0xd7, 0x0d, 0xfc, 0x2a, 0xe8, 0xed, 0x93, 0x83, 0x61, 0x33, 0xc4, 0xdf, 0xb8, 0xab, 0x76, 0x8d, 0xcc, 0xe8, 0x00, 0xe0, 0x39, 0x3e, 0x10, 0xfa, 0x7e, 0x54, 0x57, 0x1d, 0xb3, 0x05, 0xf4, 0x0d, 0x54, 0x47, 0x12, 0xf9, 0xc8, 0x0b, 0xfd, 0x32, 0x77, 0xff, 0x61, 0xa9, 0x37, 0xc4, 0xf5, 0x7e, 0xdc, 0x44, 0xa6, 0x1c, 0x33, 0x6a, 0xb7, 0xf7, 0x54, 0x96, 0x01, 0x9b, 0x75, 0x9f, 0x9e, 0xa0, 0x22, 0x25, 0x53, 0x02, 0x03, 0x01, 0x00, 0x01, 0xa3, 0x81, 0xd6, 0x30, 0x81, 0xd3, 0x30, 0x0e, 0x06, 0x03, 0x55, 0x1d, 0x0f, 0x01, 0x01, 0xff, 0x04, 0x04, 0x03, 0x02, 0x07, 0x80, 0x30, 0x16, 0x06, 0x03, 0x55, 0x1d, 0x25, 0x01, 0x01, 0xff, 0x04, 0x0c, 0x30, 0x0a, 0x06, 0x08, 0x2b, 0x06, 0x01, 0x05, 0x05, 0x07, 0x03, 0x08, 0x30, 0x1d, 0x06, 0x03, 0x55, 0x1d, 0x0e, 0x04, 0x16, 0x04, 0x14, 0xc8, 0xc4, 0x12, 0x49, 0x46, 0xd4, 0x33, 0x96, 0x20, 0x7d, 0x4e, 0xb3, 0xe5, 0x48, 0x16, 0x42, 0xec, 0x09, 0x14, 0x28, 0x30, 0x69, 0x06, 0x03, 0x55, 0x1d, 0x20, 0x04, 0x62, 0x30, 0x60, 0x30, 0x5e, 0x06, 0x0e, 0x2b, 0x06, 0x01, 0x04, 0x01, 0x95, 0x12, 0x02, 0x02, 0x04, 0x01, 0x01, 0x01, 0x01, 0x30, 0x4c, 0x30, 0x4a, 0x06, 0x08, 0x2b, 0x06, 0x01, 0x05, 0x05, 0x07, 0x02, 0x02, 0x30, 0x3e, 0x0c, 0x3c, 0x54, 0x68, 0x69, 0x73, 0x20, 0x63, 0x65, 0x72, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x65, 0x20, 0x6d, 0x61, 0x79, 0x20, 0x62, 0x65, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x64, 0x65, 0x6d, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x70, 0x75, 0x72, 0x70, 0x6f, 0x73, 0x65, 0x73, 0x20, 0x6f, 0x6e, 0x6c, 0x79, 0x30, 0x1f, 0x06, 0x03, 0x55, 0x1d, 0x23, 0x04, 0x18, 0x30, 0x16, 0x80, 0x14, 0xc8, 0xc4, 0x12, 0x49, 0x46, 0xd4, 0x33, 0x96, 0x20, 0x7d, 0x4e, 0xb3, 0xe5, 0x48, 0x16, 0x42, 0xec, 0x09, 0x14, 0x28, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x0b, 0x05, 0x00, 0x03, 0x82, 0x01, 0x01, 0x00, 0xc0, 0x04, 0x05, 0xea, 0xd1, 0x60, 0x93, 0x18, 0x1a, 0x80, 0x39, 0x51, 0x93, 0x16, 0x58, 0xfd, 0x51, 0x4f, 0xe6, 0x53, 0xc6, 0xcc, 0x15, 0xf8, 0xcf, 0xb5, 0xe9, 0x68, 0x8f, 0x22, 0xe3, 0xda, 0x29, 0x05, 0x24, 0xbc, 0x7c, 0x05, 0x45, 0x48, 0x02, 0x47, 0x8a, 0x4b, 0x34, 0x5d, 0xa2, 0x3e, 0x43, 0xe2, 0x2d, 0x19, 0xb8, 0x38, 0xe0, 0xdf, 0xba, 0x30, 0xad, 0x92, 0x75, 0xf9, 0x2c, 0x95, 0xfe, 0xde, 0x0e, 0x82, 0x11, 0x45, 0x30, 0x3d, 0x1f, 0x9d, 0x23, 0x91, 0x04, 0x84, 0x1b, 0x03, 0xce, 0x21, 0xb6, 0x8b, 0x0b, 0x03, 0xb1, 0x10, 0x0f, 0x9f, 0xe0, 0xfa, 0x24, 0x9e, 0x5b, 0x90, 0x94, 0xfd, 0x2e, 0x52, 0xe9, 0xf8, 0x3a, 0x78, 0xa2, 0xed, 0x09, 0xd7, 0xeb, 0x40, 0xe5, 0xb1, 0x91, 0x5f, 0x23, 0x72, 0x34, 0x4b, 0x9f, 0x25, 0xe4, 0xcc, 0xfa, 0x46, 0x04, 0xf4, 0xd0, 0x55, 0xd9, 0x8b, 0x36, 0xb0, 0xf2, 0x12, 0x09, 0x8f, 0x56, 0x22, 0x10, 0xfc, 0xc5, 0xd4, 0xff, 0x9e, 0xa2, 0x21, 0xfd, 0xf1, 0xe5, 0x65, 0x5c, 0x7d, 0x72, 0x62, 0x0f, 0x89, 0x44, 0xb8, 0x38, 0xf0, 0x5e, 0x07, 0x20, 0xe4, 0xb1, 0x12, 0xf4, 0xb2, 0x6a, 0xe2, 0xd3, 0xf0, 0xc7, 0x11, 0x9f, 0x21, 0x46, 0xf6, 0x54, 0xda, 0xd5, 0x77, 0xcb, 0x93, 0xa3, 0x03, 0x32, 0xb7, 0xe4, 0x26, 0xf5, 0x19, 0x37, 0x57, 0x3b, 0xd1, 0x5c, 0xc3, 0xbf, 0x95, 0x6f, 0xb3, 0xb2, 0xae, 0xb7, 0x4a, 0x9b, 0x70, 0x2a, 0x14, 0xf1, 0xe3, 0xbe, 0xc0, 0xd2, 0xcf, 0x91, 0xc5, 0x0b, 0x90, 0x5f, 0x01, 0xc1, 0xb5, 0xee, 0x42, 0x98, 0x61, 0xb9, 0x6e, 0xb0, 0x7d, 0x9c, 0x1f, 0xd1, 0x09, 0x3c, 0x6e, 0x1f, 0x70, 0xf7, 0x6f, 0x64, 0xa2, 0x15, 0xa9, 0x70, 0x0c, 0x44, 0x2c, 0xa0, 0x24, 0x7d, 0xfe, 0xc1, 0x49, 0x30, 0x82, 0x04, 0xd4, 0x30, 0x82, 0x03, 0xbc, 0xa0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x01, 0x05, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x0b, 0x05, 0x00, 0x30, 0x81, 0xc2, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x41, 0x54, 0x31, 0x0f, 0x30, 0x0d, 0x06, 0x03, 0x55, 0x04, 0x08, 0x13, 0x06, 0x53, 0x74, 0x79, 0x72, 0x69, 0x61, 0x31, 0x0d, 0x30, 0x0b, 0x06, 0x03, 0x55, 0x04, 0x07, 0x13, 0x04, 0x47, 0x72, 0x61, 0x7a, 0x31, 0x26, 0x30, 0x24, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x13, 0x1d, 0x47, 0x52, 0x41, 0x5a, 0x20, 0x55, 0x4e, 0x49, 0x56, 0x45, 0x52, 0x53, 0x49, 0x54, 0x59, 0x20, 0x4f, 0x46, 0x20, 0x54, 0x45, 0x43, 0x48, 0x4e, 0x4f, 0x4c, 0x4f, 0x47, 0x59, 0x31, 0x48, 0x30, 0x46, 0x06, 0x03, 0x55, 0x04, 0x0b, 0x13, 0x3f, 0x49, 0x6e, 0x73, 0x74, 0x69, 0x74, 0x75, 0x74, 0x65, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x41, 0x70, 0x70, 0x6c, 0x69, 0x65, 0x64, 0x20, 0x49, 0x6e, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x50, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73, 0x69, 0x6e, 0x67, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x43, 0x6f, 0x6d, 0x6d, 0x75, 0x6e, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x31, 0x21, 0x30, 0x1f, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x18, 0x49, 0x41, 0x49, 0x4b, 0x2d, 0x54, 0x53, 0x50, 0x20, 0x44, 0x45, 0x4d, 0x4f, 0x20, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x20, 0x43, 0x41, 0x30, 0x1e, 0x17, 0x0d, 0x31, 0x33, 0x30, 0x33, 0x31, 0x34, 0x31, 0x34, 0x30, 0x30, 0x31, 0x39, 0x5a, 0x17, 0x0d, 0x32, 0x33, 0x30, 0x33, 0x31, 0x34, 0x31, 0x34, 0x30, 0x30, 0x31, 0x39, 0x5a, 0x30, 0x81, 0xc2, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x41, 0x54, 0x31, 0x0f, 0x30, 0x0d, 0x06, 0x03, 0x55, 0x04, 0x08, 0x13, 0x06, 0x53, 0x74, 0x79, 0x72, 0x69, 0x61, 0x31, 0x0d, 0x30, 0x0b, 0x06, 0x03, 0x55, 0x04, 0x07, 0x13, 0x04, 0x47, 0x72, 0x61, 0x7a, 0x31, 0x26, 0x30, 0x24, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x13, 0x1d, 0x47, 0x52, 0x41, 0x5a, 0x20, 0x55, 0x4e, 0x49, 0x56, 0x45, 0x52, 0x53, 0x49, 0x54, 0x59, 0x20, 0x4f, 0x46, 0x20, 0x54, 0x45, 0x43, 0x48, 0x4e, 0x4f, 0x4c, 0x4f, 0x47, 0x59, 0x31, 0x48, 0x30, 0x46, 0x06, 0x03, 0x55, 0x04, 0x0b, 0x13, 0x3f, 0x49, 0x6e, 0x73, 0x74, 0x69, 0x74, 0x75, 0x74, 0x65, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x41, 0x70, 0x70, 0x6c, 0x69, 0x65, 0x64, 0x20, 0x49, 0x6e, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x50, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73, 0x69, 0x6e, 0x67, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x43, 0x6f, 0x6d, 0x6d, 0x75, 0x6e, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x31, 0x21, 0x30, 0x1f, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x18, 0x49, 0x41, 0x49, 0x4b, 0x2d, 0x54, 0x53, 0x50, 0x20, 0x44, 0x45, 0x4d, 0x4f, 0x20, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x20, 0x43, 0x41, 0x30, 0x82, 0x01, 0x22, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x0f, 0x00, 0x30, 0x82, 0x01, 0x0a, 0x02, 0x82, 0x01, 0x01, 0x00, 0xd8, 0xcc, 0xb6, 0x47, 0xf6, 0x66, 0x42, 0x33, 0x86, 0x49, 0x5a, 0x34, 0x65, 0x28, 0x4a, 0x7a, 0x40, 0x27, 0x8c, 0xae, 0x16, 0x52, 0x57, 0xf5, 0xd0, 0x02, 0xa0, 0x51, 0x67, 0x88, 0xc1, 0x3c, 0xdb, 0x06, 0xdf, 0x90, 0x38, 0xa8, 0xea, 0xfb, 0x52, 0x08, 0x0b, 0x55, 0xba, 0x62, 0x15, 0x9c, 0x24, 0x6d, 0xf5, 0x66, 0xbc, 0x04, 0xda, 0x2f, 0xf0, 0xfd, 0x2e, 0x57, 0x96, 0x52, 0x8d, 0xf8, 0x0a, 0x89, 0x1f, 0x56, 0x99, 0x5c, 0x1e, 0x24, 0x44, 0xe6, 0xe5, 0x50, 0x9c, 0x8b, 0x4f, 0x66, 0x81, 0x75, 0x28, 0x84, 0x21, 0xe0, 0xd0, 0x5f, 0x77, 0xba, 0x0f, 0x89, 0x5f, 0x7c, 0xf4, 0x9b, 0x91, 0x36, 0xc5, 0x87, 0x9e, 0x3d, 0xa4, 0xd9, 0xad, 0x6b, 0x3a, 0xb5, 0x11, 0x69, 0x1f, 0x0f, 0x5e, 0x59, 0x7f, 0xc0, 0xfc, 0xa1, 0xf4, 0xff, 0xaa, 0x31, 0xca, 0xba, 0xfd, 0xb5, 0x81, 0xab, 0xc9, 0x82, 0xb3, 0xc7, 0x84, 0x0d, 0x41, 0x46, 0xad, 0x1f, 0x3d, 0x81, 0x6e, 0xd1, 0x82, 0xc9, 0x22, 0x0f, 0xbc, 0x0d, 0xa6, 0x8c, 0x89, 0xf4, 0x22, 0xb4, 0x48, 0x0f, 0x41, 0xfe, 0xcd, 0x19, 0xc8, 0xca, 0xc2, 0x66, 0x93, 0xaa, 0x24, 0x71, 0xfa, 0x77, 0xe0, 0xdd, 0x5d, 0xf8, 0xe8, 0xb2, 0x62, 0xa7, 0xc1, 0x07, 0xda, 0xae, 0xf4, 0x12, 0x84, 0xdf, 0x14, 0x5f, 0xb9, 0x45, 0x90, 0x86, 0x71, 0x1c, 0xff, 0x11, 0x83, 0xc5, 0xb6, 0x54, 0x07, 0xb5, 0x13, 0xb4, 0x19, 0xae, 0xb5, 0x44, 0x1c, 0xc5, 0x29, 0x5b, 0x44, 0xf1, 0xe2, 0x68, 0x01, 0x92, 0xd6, 0xd1, 0x39, 0xd4, 0x3f, 0x45, 0xa6, 0x17, 0x76, 0x9e, 0xc2, 0x32, 0xf6, 0xb9, 0x7f, 0xb9, 0x39, 0xef, 0xa4, 0xb6, 0x8d, 0x79, 0x19, 0x00, 0xf0, 0x19, 0xc5, 0xa8, 0x6a, 0x5d, 0x6c, 0x28, 0xe1, 0x03, 0x80, 0x34, 0x49, 0x4d, 0x02, 0x03, 0x01, 0x00, 0x01, 0xa3, 0x81, 0xd2, 0x30, 0x81, 0xcf, 0x30, 0x0e, 0x06, 0x03, 0x55, 0x1d, 0x0f, 0x01, 0x01, 0xff, 0x04, 0x04, 0x03, 0x02, 0x02, 0x04, 0x30, 0x12, 0x06, 0x03, 0x55, 0x1d, 0x13, 0x01, 0x01, 0xff, 0x04, 0x08, 0x30, 0x06, 0x01, 0x01, 0xff, 0x02, 0x01, 0x00, 0x30, 0x1d, 0x06, 0x03, 0x55, 0x1d, 0x0e, 0x04, 0x16, 0x04, 0x14, 0xc8, 0xc4, 0x12, 0x49, 0x46, 0xd4, 0x33, 0x96, 0x20, 0x7d, 0x4e, 0xb3, 0xe5, 0x48, 0x16, 0x42, 0xec, 0x09, 0x14, 0x28, 0x30, 0x69, 0x06, 0x03, 0x55, 0x1d, 0x20, 0x04, 0x62, 0x30, 0x60, 0x30, 0x5e, 0x06, 0x0e, 0x2b, 0x06, 0x01, 0x04, 0x01, 0x95, 0x12, 0x02, 0x02, 0x04, 0x01, 0x01, 0x01, 0x01, 0x30, 0x4c, 0x30, 0x4a, 0x06, 0x08, 0x2b, 0x06, 0x01, 0x05, 0x05, 0x07, 0x02, 0x02, 0x30, 0x3e, 0x0c, 0x3c, 0x54, 0x68, 0x69, 0x73, 0x20, 0x63, 0x65, 0x72, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x65, 0x20, 0x6d, 0x61, 0x79, 0x20, 0x62, 0x65, 0x20, 0x75, 0x73, 0x65, 0x64, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x64, 0x65, 0x6d, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x70, 0x75, 0x72, 0x70, 0x6f, 0x73, 0x65, 0x73, 0x20, 0x6f, 0x6e, 0x6c, 0x79, 0x30, 0x1f, 0x06, 0x03, 0x55, 0x1d, 0x23, 0x04, 0x18, 0x30, 0x16, 0x80, 0x14, 0xc8, 0xc4, 0x12, 0x49, 0x46, 0xd4, 0x33, 0x96, 0x20, 0x7d, 0x4e, 0xb3, 0xe5, 0x48, 0x16, 0x42, 0xec, 0x09, 0x14, 0x28, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x0b, 0x05, 0x00, 0x03, 0x82, 0x01, 0x01, 0x00, 0x8a, 0x27, 0x20, 0xca, 0x4d, 0xce, 0xbf, 0xfe, 0xb4, 0xce, 0x95, 0xeb, 0x7e, 0x44, 0xaa, 0x81, 0xcd, 0x0f, 0x31, 0x7e, 0xea, 0x84, 0x72, 0x15, 0xfa, 0xff, 0x88, 0xcc, 0xb8, 0x8b, 0xa7, 0x85, 0x90, 0xe2, 0x71, 0x62, 0x24, 0x2f, 0x5f, 0x4b, 0xc1, 0xcf, 0xb2, 0xd9, 0xbd, 0x22, 0xa3, 0xe6, 0xc2, 0x3c, 0x6f, 0x51, 0x37, 0x10, 0xec, 0xd1, 0xc0, 0xc5, 0x38, 0x73, 0xa4, 0xa5, 0xd6, 0x82, 0xcc, 0x4d, 0xc9, 0x35, 0x89, 0x92, 0x01, 0x3a, 0x69, 0xe0, 0x99, 0x83, 0x31, 0x26, 0xc5, 0xaf, 0xd6, 0xd9, 0xf3, 0x1e, 0x08, 0x87, 0xf7, 0x5a, 0x72, 0x68, 0x4a, 0x03, 0xd3, 0xee, 0xc1, 0x99, 0x4c, 0x8a, 0xe6, 0xb4, 0x75, 0x2b, 0xaf, 0xaa, 0x26, 0xc3, 0xee, 0x0b, 0x2e, 0x67, 0x26, 0x9d, 0xcb, 0x60, 0xdc, 0x99, 0x40, 0xe9, 0x8e, 0xbc, 0x99, 0xd4, 0x8f, 0x24, 0xb3, 0xd5, 0x50, 0x88, 0x4a, 0x24, 0xfe, 0x0f, 0x82, 0x11, 0x32, 0x60, 0xb9, 0x3d, 0x7f, 0x4c, 0x10, 0x3d, 0x7a, 0xfe, 0xc8, 0x4c, 0x32, 0xee, 0xd9, 0xbc, 0x98, 0x2d, 0x0c, 0xea, 0x5a, 0xa6, 0xe8, 0x60, 0xd3, 0x2d, 0xac, 0x4a, 0x87, 0x13, 0xfe, 0x75, 0xbf, 0x3d, 0x91, 0xf1, 0x7f, 0xdd, 0xf0, 0x61, 0xcc, 0x00, 0xf5, 0xfb, 0xf7, 0x57, 0x26, 0x2b, 0x95, 0x89, 0xd0, 0x6f, 0xe1, 0x5a, 0x74, 0x1a, 0x67, 0xcf, 0x7c, 0x26, 0x17, 0xd2, 0x83, 0xda, 0x64, 0xb4, 0x39, 0xa1, 0x51, 0xbe, 0xf2, 0x8a, 0xe4, 0xf8, 0x93, 0x01, 0x17, 0x81, 0xa4, 0x08, 0xc1, 0x3b, 0xda, 0x37, 0xa7, 0xfe, 0x7b, 0xa7, 0x5c, 0x2b, 0xab, 0x13, 0x6b, 0x30, 0x2b, 0xa4, 0x66, 0x51, 0xad, 0xc6, 0x0a, 0xbf, 0x51, 0x6e, 0x24, 0x6d, 0x13, 0x20, 0x62, 0xe0, 0x98, 0xdc, 0xf5, 0x9e, 0x1a, 0xfb, 0x3d, 0x92, 0xc9, 0xf2, 0x06, 0x89, 0x31, 0x82, 0x03, 0x39, 0x30, 0x82, 0x03, 0x35, 0x02, 0x01, 0x01, 0x30, 0x81, 0xc8, 0x30, 0x81, 0xc2, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x41, 0x54, 0x31, 0x0f, 0x30, 0x0d, 0x06, 0x03, 0x55, 0x04, 0x08, 0x13, 0x06, 0x53, 0x74, 0x79, 0x72, 0x69, 0x61, 0x31, 0x0d, 0x30, 0x0b, 0x06, 0x03, 0x55, 0x04, 0x07, 0x13, 0x04, 0x47, 0x72, 0x61, 0x7a, 0x31, 0x26, 0x30, 0x24, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x13, 0x1d, 0x47, 0x52, 0x41, 0x5a, 0x20, 0x55, 0x4e, 0x49, 0x56, 0x45, 0x52, 0x53, 0x49, 0x54, 0x59, 0x20, 0x4f, 0x46, 0x20, 0x54, 0x45, 0x43, 0x48, 0x4e, 0x4f, 0x4c, 0x4f, 0x47, 0x59, 0x31, 0x48, 0x30, 0x46, 0x06, 0x03, 0x55, 0x04, 0x0b, 0x13, 0x3f, 0x49, 0x6e, 0x73, 0x74, 0x69, 0x74, 0x75, 0x74, 0x65, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x41, 0x70, 0x70, 0x6c, 0x69, 0x65, 0x64, 0x20, 0x49, 0x6e, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x50, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73, 0x69, 0x6e, 0x67, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x43, 0x6f, 0x6d, 0x6d, 0x75, 0x6e, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x31, 0x21, 0x30, 0x1f, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x18, 0x49, 0x41, 0x49, 0x4b, 0x2d, 0x54, 0x53, 0x50, 0x20, 0x44, 0x45, 0x4d, 0x4f, 0x20, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x20, 0x43, 0x41, 0x02, 0x01, 0x06, 0x30, 0x09, 0x06, 0x05, 0x2b, 0x0e, 0x03, 0x02, 0x1a, 0x05, 0x00, 0xa0, 0x82, 0x01, 0x45, 0x30, 0x1a, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x09, 0x03, 0x31, 0x0d, 0x06, 0x0b, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x09, 0x10, 0x01, 0x04, 0x30, 0x23, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x09, 0x04, 0x31, 0x16, 0x04, 0x14, 0xb0, 0x56, 0x26, 0xe5, 0x59, 0x43, 0x16, 0x72, 0x39, 0x4d, 0xf6, 0xd1, 0x5b, 0x9f, 0x56, 0xbc, 0x76, 0xba, 0x0b, 0x34, 0x30, 0x82, 0x01, 0x00, 0x06, 0x0b, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x09, 0x10, 0x02, 0x0c, 0x31, 0x81, 0xf0, 0x30, 0x81, 0xed, 0x30, 0x81, 0xea, 0x30, 0x81, 0xe7, 0x04, 0x14, 0xb2, 0xc4, 0xc2, 0x31, 0x3d, 0xf4, 0x06, 0xee, 0x57, 0x83, 0x52, 0x5e, 0xf6, 0x51, 0x04, 0xb4, 0xcd, 0x07, 0x0a, 0xf2, 0x30, 0x81, 0xce, 0x30, 0x81, 0xc8, 0xa4, 0x81, 0xc5, 0x30, 0x81, 0xc2, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x41, 0x54, 0x31, 0x0f, 0x30, 0x0d, 0x06, 0x03, 0x55, 0x04, 0x08, 0x13, 0x06, 0x53, 0x74, 0x79, 0x72, 0x69, 0x61, 0x31, 0x0d, 0x30, 0x0b, 0x06, 0x03, 0x55, 0x04, 0x07, 0x13, 0x04, 0x47, 0x72, 0x61, 0x7a, 0x31, 0x26, 0x30, 0x24, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x13, 0x1d, 0x47, 0x52, 0x41, 0x5a, 0x20, 0x55, 0x4e, 0x49, 0x56, 0x45, 0x52, 0x53, 0x49, 0x54, 0x59, 0x20, 0x4f, 0x46, 0x20, 0x54, 0x45, 0x43, 0x48, 0x4e, 0x4f, 0x4c, 0x4f, 0x47, 0x59, 0x31, 0x48, 0x30, 0x46, 0x06, 0x03, 0x55, 0x04, 0x0b, 0x13, 0x3f, 0x49, 0x6e, 0x73, 0x74, 0x69, 0x74, 0x75, 0x74, 0x65, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x41, 0x70, 0x70, 0x6c, 0x69, 0x65, 0x64, 0x20, 0x49, 0x6e, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x50, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73, 0x69, 0x6e, 0x67, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x43, 0x6f, 0x6d, 0x6d, 0x75, 0x6e, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x31, 0x21, 0x30, 0x1f, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x18, 0x49, 0x41, 0x49, 0x4b, 0x2d, 0x54, 0x53, 0x50, 0x20, 0x44, 0x45, 0x4d, 0x4f, 0x20, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x20, 0x43, 0x41, 0x02, 0x01, 0x06, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x01, 0x05, 0x00, 0x04, 0x82, 0x01, 0x00, 0xac, 0x77, 0xc3, 0x1e, 0xe4, 0x3f, 0x82, 0x3f, 0x91, 0x64, 0x38, 0x49, 0xed, 0x10, 0x06, 0x37, 0xae, 0xce, 0xa7, 0x55, 0xc0, 0xa3, 0xd9, 0xc6, 0xf7, 0x6b, 0x4c, 0x4d, 0xbb, 0x4c, 0xb7, 0x1c, 0x24, 0x6f, 0xca, 0x73, 0x80, 0x53, 0x24, 0x7e, 0xbe, 0x82, 0x09, 0xa7, 0xeb, 0xb5, 0x43, 0xc4, 0x19, 0x9f, 0x04, 0x34, 0x8e, 0xa9, 0xe7, 0xa6, 0xc3, 0x1e, 0x79, 0xaf, 0x77, 0x86, 0x72, 0xf6, 0x7c, 0x41, 0x1b, 0x29, 0xc4, 0x01, 0xf3, 0x7f, 0x4a, 0xcd, 0x93, 0xf7, 0xf9, 0xaa, 0x11, 0x34, 0x66, 0x74, 0x63, 0x63, 0x12, 0x89, 0xfc, 0xd3, 0xd3, 0xd1, 0xd6, 0x23, 0x45, 0x33, 0x6e, 0x81, 0x9e, 0xe1, 0xaf, 0x7a, 0x39, 0x1c, 0x72, 0x1b, 0x00, 0xc7, 0xf6, 0x15, 0xa2, 0xcb, 0x8e, 0xdf, 0x4e, 0xbd, 0x7b, 0xcd, 0xa1, 0xf8, 0x12, 0x89, 0x00, 0xdf, 0x8f, 0xf9, 0x55, 0x73, 0x40, 0x36, 0x61, 0x32, 0xc2, 0xee, 0xf5, 0xd3, 0x8d, 0x14, 0x2f, 0x97, 0xb5, 0xcb, 0x08, 0x81, 0x6e, 0x9a, 0x43, 0xec, 0xc4, 0x21, 0x94, 0x7f, 0x72, 0x2b, 0xd0, 0xa1, 0x95, 0xa1, 0x02, 0xd4, 0xb6, 0x4c, 0x4a, 0x89, 0x26, 0xf4, 0x95, 0xb0, 0xfb, 0x95, 0x1c, 0x7e, 0xcb, 0x8e, 0x04, 0x76, 0xa2, 0x91, 0x1a, 0x63, 0x50, 0x7d, 0x52, 0x07, 0xdd, 0xfb, 0x26, 0x09, 0xda, 0x2c, 0xbe, 0x7e, 0x34, 0xc0, 0xf5, 0x6b, 0x15, 0x84, 0xaf, 0xdd, 0x91, 0x90, 0x29, 0x39, 0x24, 0x37, 0xae, 0x04, 0xb2, 0x43, 0x67, 0x48, 0x0c, 0xa4, 0x90, 0x7d, 0x49, 0x3a, 0xa7, 0x9f, 0x5d, 0xec, 0xe5, 0xc1, 0x72, 0xac, 0x1a, 0x92, 0x82, 0xcb, 0x4d, 0xae, 0x9b, 0x09, 0x96, 0x5d, 0x04, 0xbb, 0xf7, 0xcd, 0xf6, 0xd6, 0x38, 0x8c, 0xd5, 0xa9, 0x4e, 0xd4, 0x82, 0x3b, 0x99, 0xd5, 0x86, 0x11, 0x7a, 0xef, 0xe5, 0x92}

	timeServerSignedResponse, err := timestamp.ParseResponse(tspResponse)
	if err != nil {
		calculatedEndTime.Errors = append(calculatedEndTime.Errors, fmt.Sprintf("TSP: %s", err))
	} else {
		calculatedEndTime.TimeServerCurrentTime = timeServerSignedResponse.Time
	}

	//from time chaincode
	timeChaincodeResponse := APIstub.InvokeChaincode("time-app", util.ToChaincodeArgs("GetCurrentTime"), "time-channel")
	if timeChaincodeResponse.Status != shim.OK {
		errStr := fmt.Sprintf("Failed to query chaincode. Got error: %s", timeChaincodeResponse.Payload)
		calculatedEndTime.Errors = append(calculatedEndTime.Errors, fmt.Sprintf("CHAINCODE: %s", errStr))
		// return shim.Error(errStr)
	} else {
		chaincodeCurrentTime = HyperledgerFabricTimestamp{}
		err = json.Unmarshal(timeChaincodeResponse.Payload, &chaincodeCurrentTime)
		if err == nil {
			calculatedEndTime.ChaincodeCurrentTime = chaincodeCurrentTime.CurrentTime
		}
	}

	parkingTime.CurrentTimestamps = calculatedEndTime
	//END

	parkingTime.ParkingEnd = calculatedEndTime.TransactionTime

	delta := parkingTime.ParkingEnd.Sub(parkingTime.ParkingStart)
	parkingTime.Cost = int(delta.Minutes()) * parkingTime.CostPerMinute

	s.ParkingTimeService.Save(APIstub, parkingTime)
	fmt.Printf("Saved parking type: %s\n", parkingTime)

	owner, err := s.UserService.Get(APIstub, parkingTime.Parkingspot.Owner.Id)
	if err != nil {
		return shim.Error(fmt.Sprintf("Failed to change parkingspot owner balance: %s", err))
	}

	renter, err := s.UserService.Get(APIstub, parkingTime.Renter.Id)
	if err != nil {
		return shim.Error(fmt.Sprintf("Failed to change renter balance: %s", err))
	}

	owner.Balance.Amount += parkingTime.Cost
	renter.Balance.Amount -= parkingTime.Cost

	owner, err = s.UserService.Save(APIstub, owner)
	if err != nil {
		return shim.Error(fmt.Sprintf("Failed to add parkingspot owner balance: %s", err))
	}
	renter, err = s.UserService.Save(APIstub, renter)
	if err != nil {
		return shim.Error(fmt.Sprintf("Failed to reduce renter balance: %s", err))
	}

	resultAsBytes, _ := json.Marshal(parkingTime)
	return shim.Success(resultAsBytes)
}

func (s *SmartContract) get(APIstub shim.ChaincodeStubInterface, id string) (ParkingTime, error) {
	resultAsBytes, err := APIstub.GetState(id)
	parkingTime := ParkingTime{}
	if err != nil {
		return parkingTime, err
	}
	if resultAsBytes == nil {
		return parkingTime, nil
	}
	err = json.Unmarshal(resultAsBytes, &parkingTime)
	if err != nil {
		return parkingTime, err
	}

	return parkingTime, nil
}

func (s *SmartContract) put(APIstub shim.ChaincodeStubInterface, id string, parkingTime ParkingTime) ([]byte, error) {
	resultAsBytes, err := json.Marshal(parkingTime)
	if err != nil {
		return resultAsBytes, err
	}
	err = APIstub.PutState(id, resultAsBytes)
	return resultAsBytes, err
}

// func (s *SmartContract) findParkingspotOverlaping(APIstub shim.ChaincodeStubInterface, ParkingStart time.Time, ParkingEnd time.Time) (shim.StateQueryIteratorInterface, error) {
func (s *SmartContract) findParkingspotOverlaping(APIstub shim.ChaincodeStubInterface, ParkingStart string, ParkingEnd string) (shim.StateQueryIteratorInterface, error) {
	queryString := fmt.Sprintf("{\"selector\": {\"parkingStart\": {\"$lte\": \"%s\"}, \"parkingEnd\": {\"$gte\": \"%s\"}}}", ParkingEnd, ParkingStart)
	resultsIterator, err := APIstub.GetQueryResult(queryString)
	if err != nil {
		return resultsIterator, err
	}
	defer resultsIterator.Close()

	return resultsIterator, nil
}

func (s *SmartContract) unmarshal(jsonStringBody string) (ParkingTime, error) {
	parkingTime := ParkingTime{}
	err := json.Unmarshal([]byte(jsonStringBody), &parkingTime)
	return parkingTime, err
}

func (s *SmartContract) marshalQueryResult(resultsIterator shim.StateQueryIteratorInterface) (string, error) {
	// buffer is a JSON array containing QueryResults
	var buffer bytes.Buffer
	buffer.WriteString("[")

	bArrayMemberAlreadyWritten := false
	for resultsIterator.HasNext() {
		queryResponse, err := resultsIterator.Next()
		if err != nil {
			return "", err
		}
		// Add comma before array members,suppress it for the first array member
		if bArrayMemberAlreadyWritten == true {
			buffer.WriteString(",")
		}
		buffer.WriteString("{\"Key\":")
		buffer.WriteString("\"")
		buffer.WriteString(queryResponse.Key)
		buffer.WriteString("\"")

		buffer.WriteString(", \"Record\":")
		// Record is a JSON object, so we write as-is
		buffer.WriteString(string(queryResponse.Value))
		buffer.WriteString("}")
		bArrayMemberAlreadyWritten = true
	}
	buffer.WriteString("]")
	return buffer.String(), nil
}

/*
 * main function *
calls the Start function
The main function starts the chaincode in the container during instantiation.
*/
func main() {

	// Create a new Smart Contract
	err := shim.Start(&SmartContract{
		ParkingspotService:   parkingservice.GetParkingspotService(),
		ParkingTimeService:   parkingservice.GetParkingTimeService(),
		UserService:          parkingservice.GetUserService(),
		ParkingCommonService: parkingservice.GetParkingCommonService(),
	})
	if err != nil {
		fmt.Printf("Error creating new Smart Contract: %s", err)
	} else {
		fmt.Println("SVENZIK SampleChaincode successfully started")
	}
}
